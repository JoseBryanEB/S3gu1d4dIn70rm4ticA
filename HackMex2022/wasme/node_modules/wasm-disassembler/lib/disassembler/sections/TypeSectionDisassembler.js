"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const FunctionType_1 = require("../../wasmTypes/FunctionType");
class TypeSectionDisassembler {
    constructor(binaryProvider) {
        this.binaryProvider = binaryProvider;
    }
    Disassemble(initialPointer) {
        let result = [];
        let pointer = initialPointer;
        const nFuncTypesLength = this.binaryProvider.Getu32(pointer);
        const numberOfFuncTypes = nFuncTypesLength.Value;
        pointer += nFuncTypesLength.BytesUsed;
        while (result.length < numberOfFuncTypes) {
            let readFunctypeRes;
            [readFunctypeRes, pointer] = TypeSectionDisassembler.ReadFuncType(this.binaryProvider, pointer);
            if (!readFunctypeRes) {
                throw new Error("Could not read func type.");
            }
            result.push(readFunctypeRes);
        }
        return result;
    }
    static ReadFuncType(binaryProvider, initialPointer) {
        let result = null;
        let pointer = initialPointer;
        if (binaryProvider.GetRawByte(pointer) !== TypeSectionDisassembler.FuncTypeStartingByte) {
            throw new Error("Expected byte to be 0x60 as is the start of a functype");
        }
        result = new FunctionType_1.FunctionType();
        pointer += 1;
        const nParamsLengthRes = binaryProvider.Getu32(pointer);
        const numberOfParams = nParamsLengthRes.Value;
        pointer += nParamsLengthRes.BytesUsed;
        let params = [];
        while (params.length < numberOfParams) {
            const valueType = binaryProvider.ReadValueType(pointer);
            if (valueType) {
                params.push(valueType);
                pointer++;
            }
        }
        let resTypes = [];
        const resTypesParamsLength = binaryProvider.Getu32(pointer);
        const numberOfResultTypes = resTypesParamsLength.Value;
        pointer += resTypesParamsLength.BytesUsed;
        while (resTypes.length < numberOfResultTypes) {
            const valueType = binaryProvider.ReadValueType(pointer);
            if (valueType) {
                resTypes.push(valueType);
                pointer++;
            }
        }
        result.Parameters = params;
        result.ResultTypes = resTypes;
        return [result, pointer];
    }
}
TypeSectionDisassembler.FuncTypeStartingByte = 0x60;
exports.TypeSectionDisassembler = TypeSectionDisassembler;
//# sourceMappingURL=TypeSectionDisassembler.js.map