"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Import_1 = require("../../imports/Import");
const Table_1 = require("../../Table");
const Memory_1 = require("../../Memory");
const Global_1 = require("../../Global");
const WasmFunction_1 = require("../../functions/WasmFunction");
var ImportTypes;
(function (ImportTypes) {
    ImportTypes[ImportTypes["function"] = 0] = "function";
    ImportTypes[ImportTypes["table"] = 1] = "table";
    ImportTypes[ImportTypes["mem"] = 2] = "mem";
    ImportTypes[ImportTypes["global"] = 3] = "global";
})(ImportTypes || (ImportTypes = {}));
/**
 * Disassembles the Imports of an Import Section as described by the WASM binary
 * encoding specification.
 * @see https://webassembly.github.io/spec/core/bikeshed/index.html#binary-import
 */
class ImportSectionDisassembler {
    constructor(binaryProvider) {
        this.binaryProvider = binaryProvider;
    }
    Disassemble(initialPointer) {
        let result = [];
        let pointer = initialPointer;
        let importsLengthU32 = this.binaryProvider.Getu32(pointer);
        pointer += importsLengthU32.BytesUsed;
        while (result.length < importsLengthU32.Value) {
            let newImport;
            [newImport, pointer] = this.FindImport(pointer);
            result.push(newImport);
        }
        return result;
    }
    /**
     * Disassembles an import according to WASM specification.
     * @see https://webassembly.github.io/spec/core/bikeshed/index.html#syntax-import
     *
     * @param binaryProvider provider of binary layer of the encoded WASM.
     * @param initialPointer position in the byte array where to start looking for the import.
     */
    FindImport(initialPointer) {
        let newImport = new Import_1.Import();
        let pointer = initialPointer;
        let moduleName;
        [moduleName, pointer] = this.binaryProvider.ReadName(pointer);
        if (!moduleName) {
            throw new Error("Could not determine module name in import");
        }
        newImport.Module = moduleName;
        let entityName;
        [entityName, pointer] = this.binaryProvider.ReadName(pointer);
        if (!entityName) {
            throw new Error("Could not determine module name in import");
        }
        newImport.EntityName = entityName;
        const typeOfImport = this.binaryProvider.GetRawByte(pointer);
        let importable = ImportSectionDisassembler.InstantiateImportable(typeOfImport);
        newImport.Content = importable;
        pointer++;
        return [newImport, pointer];
    }
    static InstantiateImportable(importableType) {
        if (!Object.values(ImportTypes).includes(importableType)) {
            throw new Error(`The importable type specified does not exist: ${importableType}`);
        }
        let newImportable = new ImportSectionDisassembler.ImportablesMapping[importableType]();
        return newImportable;
    }
}
ImportSectionDisassembler.ImportablesMapping = {
    [ImportTypes.table]: Table_1.Table,
    [ImportTypes.mem]: Memory_1.Memory,
    [ImportTypes.global]: Global_1.Global,
    [ImportTypes.function]: WasmFunction_1.WasmFunction,
};
exports.ImportSectionDisassembler = ImportSectionDisassembler;
//# sourceMappingURL=ImportSectionDisassembler.js.map