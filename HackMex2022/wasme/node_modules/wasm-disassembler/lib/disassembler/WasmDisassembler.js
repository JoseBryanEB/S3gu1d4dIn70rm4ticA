"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Section_1 = require("../sections/Section");
const WasmModule_1 = require("../WasmModule");
const Mapping_1 = require("../sections/Mapping");
const Disassembly_1 = require("./Disassembly");
const SectionDisassembler_1 = require("./sections/SectionDisassembler");
const logger_1 = require("../logging/logger");
const simpleLogger_1 = require("../logging/simpleLogger");
class WasmDisassembler {
    constructor(binaryProvider, logger = new simpleLogger_1.SimpleLogger(null)) {
        this.bp = binaryProvider;
        this.logger = logger;
        this.log = (message) => { this.logger.log(message, logger_1.LoggingVerbosity.Trace); };
    }
    Disassemble() {
        return __awaiter(this, void 0, void 0, function* () {
            const disassembly = new Disassembly_1.Disassembly();
            disassembly.FileSize = this.bp.Length;
            disassembly.Modules = this.FindModules(0);
            return disassembly;
        });
    }
    FindModules(startPointer) {
        let pointer = startPointer;
        let modules = [];
        while (pointer < this.bp.Length) {
            const moduleResult = this.FindModule(pointer);
            if (moduleResult) {
                let module;
                [module, pointer] = moduleResult;
                modules.push(module);
            }
            else {
                break;
            }
        }
        return modules;
    }
    FindModule(startPointer) {
        let pointer = startPointer;
        this.log(`Looking for module at pointer ${pointer}`);
        if (!this.FindMagicNumber(pointer)) {
            this.log('Could not find initial fingerprint');
            return null;
        }
        pointer += WasmModule_1.WasmModule.MagicNumberLength;
        const version = this.FindVersion(pointer);
        if (version !== WasmModule_1.WasmVersions.Normal) {
            this.log(`Module versio is not normal version. Version found: ${version}`);
            return null;
        }
        pointer += WasmModule_1.WasmModule.VersionLength;
        const sections = this.FindSections(pointer);
        let module = new WasmModule_1.WasmModule();
        [module.Sections, pointer] = sections;
        return [module, pointer];
    }
    FindMagicNumber(initialPointer) {
        const fingerprint = this.bp.GetRawUint32(initialPointer);
        if (fingerprint !== WasmModule_1.WasmModule.MagicNumber) {
            return false;
        }
        this.log('Fingerprint found :)');
        return true;
    }
    FindVersion(initialPointer) {
        const version = this.bp.GetRawUint32(initialPointer);
        if (!Object.values(WasmModule_1.WasmVersions).includes(version)) {
            this.log(`Version unknown: ${version}`);
            return null;
        }
        this.log(`Found version: ${WasmModule_1.WasmVersions[version]}`);
        return version;
    }
    FindSections(initialPointer) {
        let pointer = initialPointer;
        const maxIts = 500;
        let its = 0;
        let sections = [];
        while ((pointer + WasmDisassembler.SectionIdLength + 5) < this.bp.Length) {
            its++;
            if (its > maxIts && false) {
                break;
            }
            const findSectionResult = this.FindSection(pointer);
            let newSection;
            if (findSectionResult) {
                [newSection, pointer] = findSectionResult;
                sections.push(newSection);
            }
            else {
                this.log('Could not find more sections :/');
                break;
            }
        }
        return [sections, pointer];
    }
    FindSection(initialPointer) {
        this.log(`Finding section header at pointer ${initialPointer}`);
        let pointer = initialPointer;
        if (pointer >= this.bp.Length) {
            return null; // no section header available
        }
        if (pointer < this.bp.Length - 4 && this.FindMagicNumber(pointer)) {
            return null; // no section header available
        }
        if (!this.HasVarIntBytes(pointer)) {
            return null;
        }
        const sectionType = this.GetSectionId(pointer);
        if (sectionType === null) {
            return null;
        }
        let newSection = Mapping_1.InstantiateSection(sectionType);
        pointer += WasmDisassembler.SectionIdLength;
        const csu32 = this.bp.Getu32(pointer);
        const contentSize = csu32.Value;
        pointer += csu32.BytesUsed;
        newSection.sectionId = sectionType;
        newSection.contentSize = contentSize;
        const sectionDisassembler = SectionDisassembler_1.InstantiateSectionDisassembler(this.bp, newSection.sectionId);
        const sectionDisassembly = sectionDisassembler.Disassemble(pointer);
        newSection.ReceivePayload(sectionDisassembly);
        pointer += contentSize;
        return [newSection, pointer];
    }
    GetSectionId(initialPointer) {
        const sectionIdAsNumber = this.bp.GetRawByte(initialPointer);
        if (!Mapping_1.PossibleSections.includes(sectionIdAsNumber)) {
            this.log(`Unknown section id: ${sectionIdAsNumber}`);
            return null;
        }
        this.log(`Found a section ID: ${Section_1.SectionIds[sectionIdAsNumber]}`);
        return sectionIdAsNumber;
    }
    HasVarIntBytes(initialPointer) {
        let pointer = initialPointer;
        while (pointer < this.bp.Length) {
            if ((this.bp.GetRawByte(pointer) & 0x80) === 0) {
                return true;
            }
            pointer++;
        }
        return false;
    }
}
WasmDisassembler.SectionIdLength = 1;
exports.WasmDisassembler = WasmDisassembler;
//# sourceMappingURL=WasmDisassembler.js.map